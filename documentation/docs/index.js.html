<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Represents a set of points for convex hull computation.
 * @typedef {Object} Point
 * @property {number} x - The x-coordinate of the point.
 * @property {number} y - The y-coordinate of the point.
 */

/**
 * Represents a line segment between two points.
 * @typedef {Object} Line
 * @property {Point} start - The starting point of the line segment.
 * @property {Point} end - The ending point of the line segment.
 */

/**
 *An upper bridge is a horizontal line segment that connects 
 *two points on the convex hull, where all other points lie 
 *below this line. It represents a critical boundary in the
  *convex hull, separating the upper and lower parts.
 
*Identification of Upper Bridge:

*In the Kirkpatrick–Seidel algorithm, identifying the upper 
*bridge involves a divide-and-conquer approach. The algorithm
*recursively divides the point set into smaller subsets until
*a base case is reached (e.g., a small enough subset of points).
 Finding Upper Bridge Candidates:

*Within each subset, the algorithm finds candidate upper bridges.
*These are potential horizontal line segments that could be part
*of the upper bridge. The criteria for selecting candidate bridges 
*ensure that they connect two points on the convex hull and have 
*all other points below them.
*Selecting the Upper Bridge:

*From the candidate bridges found in each subset, the algorithm selects 
*the upper bridge with the lowest y-coordinate among the upper hull points. 
*This ensures that the selected bridge spans the upper part of the convex hull.
*Merging Convex Hulls:

*Once the upper bridge is identified in each subset, the algorithm merges these
*smaller convex hulls to construct the final convex hull of the entire point set. 
*The upper bridge acts as a key connector in this merging process, ensuring that
*the convex hull remains correctly formed.
*Geometric Interpretation:

*Geometrically, the upper bridge represents the highest horizontal boundary
*within a subset that forms part of the convex hull. It's a critical element 
*in dividing and conquering the problem of computing the convex hull efficiently.
*In summary, the upper bridge in the Kirkpatrick–Seidel algorithm serves as a dividing 
*line that helps in recursively partitioning the point set and merging convex hulls, 
*ultimately leading to the efficient computation of the overall convex hull. 
*Its identification and proper handling are essential for the algorithm's correctness and
*computational effectiveness.
 * @typedef {Object} Bridge
 * @property {Point} pk - The leftmost point of the bridge.
 * @property {Point} pm - The rightmost point of the bridge.
 */

/**
 * Draws a line segment between two points on the SVG canvas.
 * @param {Point} start - The starting point of the line segment.
 * @param {Point} end - The ending point of the line segment.
 * @param {string} color - The color of the line segment.
 * @param {string} ptColor - The color of the points connected by the line segment.
 */
function drawLine(start, end, color, ptColor) {
    // Implementation
}

/**
 * Draws a line segment for the median calculation.
 * The Kirkpatrick–Seidel algorithm splits the input as before, by finding the median of the x-coordinates of the input points. 
 * @param {Point} start - The starting point of the line segment.
 * @param {Point} end - The ending point of the line segment.
 */
function medianDrawLine(start, end) {
    // Implementation
}

/**
 * Draws a point on the canvas.
 * @param {number} x - The x-coordinate of the point.
 * @param {number} y - The y-coordinate of the point.
 * @param {string} color - The color of the point.
 * @param {string} radius - The radius of the point.
 * @param {string} dis - The displacement of the point.
 */
function drawPoint(x, y, color, radius, dis) {
    // Implementation
}

/**
 * Removes a median line segment from the SVG canvas.
 */
function removeMedianLine() {
    // Implementation
}

/**
 * Removes a line segment between two points.
 * @param {Point} start - The starting point of the line segment.
 * @param {Point} end - The ending point of the line segment.
 */
function removeLine(start, end) {
    // Implementation
}

/**
 * Filters unique elements from an array of points.
 * @param {Point[]} array - The array of points to filter.
 * @returns {Point[]} - The array of unique points.
 */
function keepUniqueElements(array) {
    // Implementation
    return uniqueArray;
}

/**
 * Finds the minimum and maximum points from a given set of points.
 * @param {Point[]} points - The array of points.
 * @returns {Object} - The object containing the minimum and maximum points.
 */
function findminmax(points) {
    // Implementation
    return { pumax, pumin, plmax, plmin };
}

/**
 * Removes lower points from the canvas based on given conditions.
 * @param {Point[]} Lower - The array of lower points.
 * @param {Point} plmin - The minimum point on the lower side.
 * @param {Point} plmax - The maximum point on the lower side.
 */
function removeLowerPoints(Lower, plmin, plmax) {
    // Implementation
}

/**
 * Removes points from the canvas based on given conditions.
 * The points on the left and right sides of the splitting line that cannot contribute to the eventual hull are discarded, and the algorithm proceeds recursively on the remaining points.
 * @param {Point[]} ptsToRemove - The array of points to remove.
 */
function removePoints(ptsToRemove) {
    // Implementation
}

/**
 * Redraws lower points on the canvas.
 * @param {Point[]} Lower - The array of lower points.
 */
function getLowerAgain(Lower) {
    // Implementation
}

/**
 * Computes the convex hull of a set of points using the KPSAlgorithm algorithm.
 * Purpose: The Kirkpatrick–Seidel algorithm is used to find the closest pair of points among a set of points in the Euclidean plane. It's a divide-and-conquer algorithm that efficiently solves the closest pair problem.

*Algorithm Steps:

*Preprocessing: The algorithm preprocesses the points to build a data structure that allows for efficient querying of the closest pair.
*Divide and Conquer: It divides the set of points into smaller subsets, typically recursively, until the subsets are small enough to compute the closest pair directly.
*Combine Step: After finding the closest pairs in the smaller subsets, it combines these results to determine the overall closest pair of points in the entire set.
*Data Structures:
*The Kirkpatrick–Seidel algorithm is efficient and has a time complexity of O(n log n), where n is the number of points in the input set.
*It's particularly useful for large sets of points, as it avoids the O(n^2) complexity of naive pairwise comparisons.
Applications:
*Computational Geometry: The algorithm is used in various geometric applications, such as computer graphics, GIS (Geographic Information Systems), and robotics.
Nearest Neighbor Search: It's also applied in problems related to nearest neighbor search and clustering algorithms.
 * @param {Point[]} points - The array of points.
 * @returns {Point[]} - The array of points on the convex hull.
 */
function ConvexHull(points) {
    // Implementation
    return UpperHullPoints;
}

/**
 * Computes the upper hull of a set of points.
 * @param {Point} pumin - The minimum point on the upper side.
 * @param {Point} pumax - The maximum point on the upper side.
 * @param {Point[]} Upper - The array of upper points.
 * @returns {Point[]} - The array of points on the upper hull.
 */
function UpperHull(pumin, pumax, Upper) {
    // Implementation
    return UpperHullPoints;
}

/**
 * Computes the lower hull of a set of points.
 * @param {Point} plmin - The minimum point on the lower side.
 * @param {Point} plmax - The maximum point on the lower side.
 * @param {Point[]} Lower - The array of lower points.
 * @returns {Point[]} - The array of points on the lower hull.
 */
function LowerHull(plmin, plmax, Lower) {
    // Implementation
    return LowerHullPoints;
}

/**
 * @param {Point[]} S - The array of points.
 * @param {number} a - The value of 'a' for computing the bridge.
 * @returns {Bridge} - The bridge between two sets of points.
 */
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#ConvexHull">ConvexHull</a></li><li><a href="global.html#LowerHull">LowerHull</a></li><li><a href="global.html#UpperHull">UpperHull</a></li><li><a href="global.html#drawLine">drawLine</a></li><li><a href="global.html#drawPoint">drawPoint</a></li><li><a href="global.html#findminmax">findminmax</a></li><li><a href="global.html#getLowerAgain">getLowerAgain</a></li><li><a href="global.html#keepUniqueElements">keepUniqueElements</a></li><li><a href="global.html#medianDrawLine">medianDrawLine</a></li><li><a href="global.html#removeLine">removeLine</a></li><li><a href="global.html#removeLowerPoints">removeLowerPoints</a></li><li><a href="global.html#removeMedianLine">removeMedianLine</a></li><li><a href="global.html#removePoints">removePoints</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue Apr 02 2024 21:37:25 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
